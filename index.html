<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PromptHQ</title>
  <style>
    @font-face {
      font-family: 'StackSansText';
      src: url('StackSansText-Bold.ttf') format('truetype');
      font-weight: 700;
      font-display: swap;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      background: #000000;
      overflow: hidden;
    }
    canvas { position: fixed; top: 0; left: 0; display: block; }
    .loader {
      position: fixed; inset: 0; background: #000000;
      display: flex; align-items: center; justify-content: center;
      z-index: 100; transition: opacity 0.8s ease, visibility 0.8s ease;
    }
    .loader.hidden { opacity: 0; visibility: hidden; }
    .loader-ring {
      width: 48px; height: 48px;
      border: 3px solid rgba(255,255,255,0.2);
      border-top-color: #fff; border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div class="loader" id="loader"><div class="loader-ring"></div></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(40, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 0, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ── GPU Fluid Simulation (Navier-Stokes) ──
    const FLUID_SIZE = 128;
    const fluidOpts = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      type: THREE.HalfFloatType,
      depthBuffer: false,
      stencilBuffer: false,
    };
    let fluidRT_A = new THREE.WebGLRenderTarget(FLUID_SIZE, FLUID_SIZE, fluidOpts);
    let fluidRT_B = new THREE.WebGLRenderTarget(FLUID_SIZE, FLUID_SIZE, fluidOpts);
    let curlRT = new THREE.WebGLRenderTarget(FLUID_SIZE, FLUID_SIZE, fluidOpts);

    const fluidQuadGeo = new THREE.PlaneGeometry(2, 2);
    const fluidOrtho = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    // Fluid pointer state
    const pointerPos = new THREE.Vector2(0.5, 0.5);
    const pointerVec = new THREE.Vector2(0, 0);
    const prevPointerPos = new THREE.Vector2(0.5, 0.5);

    // Common fluid vertex shader
    const fluidVertShader = /* glsl */`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `;

    // Pass 1: Curl (vorticity)
    const curlMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          float L = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).y;
          float R = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).y;
          float T = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).x;
          float B = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).x;
          float curl = (R - L) - (T - B);
          gl_FragColor = vec4(curl * 0.5 + 0.5, 0.0, 0.0, 1.0);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 2: Velocity (vorticity confinement + mouse injection)
    const velocityMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform sampler2D curlTex;
        uniform vec2 dataSize;
        uniform vec2 pointerPos;
        uniform vec2 pointerVec;
        uniform float dt;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          vec2 vel = data.xy;

          // Vorticity confinement
          float cL = texture2D(curlTex, (fc - vec2(1.0, 0.0)) / dataSize).x - 0.5;
          float cR = texture2D(curlTex, (fc + vec2(1.0, 0.0)) / dataSize).x - 0.5;
          float cT = texture2D(curlTex, (fc + vec2(0.0, 1.0)) / dataSize).x - 0.5;
          float cB = texture2D(curlTex, (fc - vec2(0.0, 1.0)) / dataSize).x - 0.5;
          float cC = texture2D(curlTex, uv).x - 0.5;

          vec2 force = vec2(abs(cT) - abs(cB), abs(cR) - abs(cL));
          float fLen = length(force);
          force = fLen > 0.0001 ? force / fLen : vec2(0.0);
          vel += force * cC * 0.15 * dt;

          // Mouse injection
          float pv = length(pointerVec);
          float splatRadius = 0.03 + 0.15 * min(1.0, pv);
          float dist = distance(uv, pointerPos);
          float splat = exp(-dist * dist / (splatRadius * splatRadius));
          vel += pointerVec * splat * 80.0 * dt;

          gl_FragColor = vec4(vel, data.zw);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        curlTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
        pointerPos: { value: pointerPos },
        pointerVec: { value: pointerVec },
        dt: { value: 0.016 },
      },
    });

    // Pass 3: Divergence (store in .w channel)
    const divergenceMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          float L = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).x;
          float R = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).x;
          float T = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).y;
          float B = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).y;
          float div = -0.5 * (R - L + T - B);
          gl_FragColor = vec4(data.xy, 0.0, div);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 4: Pressure (Jacobi iteration)
    const pressureMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          float pL = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).z;
          float pR = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).z;
          float pT = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).z;
          float pB = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).z;
          float pressure = (pL + pR + pT + pB + data.w) * 0.25;
          gl_FragColor = vec4(data.xy, pressure, data.w);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 5: Gradient Subtract
    const gradSubMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          vec2 vel = data.xy;
          float pL = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).z;
          float pR = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).z;
          float pT = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).z;
          float pB = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).z;
          vel -= 0.5 * vec2(pR - pL, pT - pB);
          gl_FragColor = vec4(vel, data.zw);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 6: Advect (Semi-Lagrangian)
    const advectMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        uniform float dt;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec2 vel = texture2D(dataTex, uv).xy;
          vec2 prevUv = (fc - vel * dt * dataSize) / dataSize;
          vec4 result = texture2D(dataTex, prevUv);
          result.xy *= 0.995; // dissipation
          gl_FragColor = result;
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
        dt: { value: 0.016 },
      },
    });

    const fluidQuad = new THREE.Mesh(fluidQuadGeo, curlMat);
    const fluidScene = new THREE.Scene();
    fluidScene.add(fluidQuad);

    function runFluidPass(mat, output) {
      fluidQuad.material = mat;
      renderer.setRenderTarget(output);
      renderer.render(fluidScene, fluidOrtho);
    }

    // Quaternion rotation state
    const mouseRotQuat = new THREE.Quaternion();
    const autoRotQuat = new THREE.Quaternion();
    const identityQuat = new THREE.Quaternion();
    const autoSpinAxis = new THREE.Vector3(0, 0, 1);
    const tempEuler = new THREE.Euler(0, 0, 0);
    let hoverVelX = 0, hoverVelY = 0; // angular velocity from mouse
    let prevAnimTime = 0;

    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment()).texture;
    pmrem.dispose();

    // ── Render target for refraction (2-pass rendering) ──
    const rtW = Math.floor(innerWidth * Math.min(devicePixelRatio, 2));
    const rtH = Math.floor(innerHeight * Math.min(devicePixelRatio, 2));
    const backgroundRT = new THREE.WebGLRenderTarget(rtW, rtH, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
    });

    // ── Noise texture (256x256 random RGBA via Canvas2D) ──
    const noiseCanvas = document.createElement('canvas');
    noiseCanvas.width = noiseCanvas.height = 256;
    const noiseCtx = noiseCanvas.getContext('2d');
    const noiseData = noiseCtx.createImageData(256, 256);
    for (let i = 0; i < noiseData.data.length; i++) {
      noiseData.data[i] = Math.random() * 255;
    }
    noiseCtx.putImageData(noiseData, 0, 0);
    const noiseTex = new THREE.CanvasTexture(noiseCanvas);
    noiseTex.wrapS = noiseTex.wrapT = THREE.RepeatWrapping;
    noiseTex.magFilter = THREE.NearestFilter;
    noiseTex.minFilter = THREE.NearestFilter;

    // ── BGQuadTree — Instanced cube tiles on a cylinder ──

    // Quad-tree subdivision: recursively split a rectangle into 4 children
    function buildQuadTree(x, y, w, h, depth, maxDepth, tiles) {
      // Random split probability decreases with depth
      const splitProb = [0.85, 0.6, 0.35, 0.2];
      if (depth >= maxDepth || Math.random() > (splitProb[depth] || 0.1)) {
        // Leaf node → emit a tile
        tiles.push({ x, y, w, h });
        return;
      }
      const hw = w / 2, hh = h / 2;
      buildQuadTree(x,      y,      hw, hh, depth + 1, maxDepth, tiles);
      buildQuadTree(x + hw, y,      hw, hh, depth + 1, maxDepth, tiles);
      buildQuadTree(x,      y + hh, hw, hh, depth + 1, maxDepth, tiles);
      buildQuadTree(x + hw, y + hh, hw, hh, depth + 1, maxDepth, tiles);
    }

    // Generate tiles over an 8×6 base grid
    const tiles = [];
    const baseCols = 8, baseRows = 6;
    for (let r = 0; r < baseRows; r++) {
      for (let c = 0; c < baseCols; c++) {
        buildQuadTree(c / baseCols, r / baseRows, 1 / baseCols, 1 / baseRows, 0, 2, tiles);
      }
    }

    // Build InstancedBufferGeometry from a BoxGeometry template
    const tileBox = new THREE.BoxGeometry(1, 1, 1);
    const tileGeo = new THREE.InstancedBufferGeometry();
    tileGeo.index = tileBox.index;
    tileGeo.attributes.position = tileBox.attributes.position;
    tileGeo.attributes.normal = tileBox.attributes.normal;
    tileGeo.attributes.uv = tileBox.attributes.uv;

    const instanceCount = tiles.length;
    const aPos = new Float32Array(instanceCount * 2);    // center in 0..1 UV space
    const aScale = new Float32Array(instanceCount * 2);  // size in 0..1 UV space
    const aRand = new Float32Array(instanceCount * 4);   // random per-instance IDs

    for (let i = 0; i < instanceCount; i++) {
      const t = tiles[i];
      aPos[i * 2]     = t.x + t.w * 0.5;  // center X (0..1)
      aPos[i * 2 + 1] = t.y + t.h * 0.5;  // center Y (0..1)
      aScale[i * 2]     = t.w;
      aScale[i * 2 + 1] = t.h;
      aRand[i * 4]     = Math.random();
      aRand[i * 4 + 1] = Math.random();
      aRand[i * 4 + 2] = Math.random();
      aRand[i * 4 + 3] = Math.random();
    }

    tileGeo.setAttribute('aPos',   new THREE.InstancedBufferAttribute(aPos, 2));
    tileGeo.setAttribute('aScale', new THREE.InstancedBufferAttribute(aScale, 2));
    tileGeo.setAttribute('aRand',  new THREE.InstancedBufferAttribute(aRand, 4));
    tileGeo.instanceCount = instanceCount;

    // Tile vertex shader — cylindrical wrapping matching the grid
    const tileVertShader = /* glsl */`
      attribute vec2 aPos;    // tile center in 0..1
      attribute vec2 aScale;  // tile size in 0..1
      attribute vec4 aRand;   // random per-instance

      uniform vec3 uScale;    // same as grid: vec3(14, 10, 1)

      varying vec2 vUv;
      varying vec2 vGlobalUv;
      varying float vSideFace;
      varying vec4 vInstanceID;

      #define PI 3.14159265359

      void main() {
        vUv = uv;
        vInstanceID = aRand;

        // Local vertex in box [-0.5..0.5]
        vec3 localV = position;

        // Detect side face: front/back faces have |normal.z| close to 1
        vSideFace = step(0.5, abs(normal.z));

        // Scale box to tile size (in 0..1 UV -> world units)
        // Gap between tiles: shrink slightly (0.92 keeps a visible gap)
        float gap = 0.92;
        float tileW = aScale.x * gap;
        float tileH = aScale.y * gap;
        float tileDepth = min(aScale.x, aScale.y) * 0.3; // depth proportional to smallest dim

        localV.x *= tileW;
        localV.y *= tileH;
        localV.z *= tileDepth;

        // Position in 0..1 UV space -> -0.5..0.5 centered
        float uvX = aPos.x + localV.x - 0.5;
        float uvY = aPos.y + localV.y - 0.5;

        // Global UV for later use
        vGlobalUv = vec2(aPos.x + localV.x, aPos.y + localV.y);

        // Cylindrical wrap (matching grid: theta = localPos.x * PI)
        float theta = uvX * PI;
        float radius = uScale.x * 0.5;
        float depth = localV.z; // front/back offset

        vec3 pos = vec3(
          sin(theta) * (radius + depth),
          uvY * uScale.y * 1.5,
          -cos(theta) * (radius + depth)
        );

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    // Tile fragment shader — Pattern 1: blue/purple noise + halftone + fluid emission
    const tileFragShader = /* glsl */`
      varying vec2 vUv;
      varying vec2 vGlobalUv;
      varying float vSideFace;
      varying vec4 vInstanceID;
      uniform sampler2D uFluidsTex;
      uniform sampler2D uNoiseTex;
      uniform float uTime;

      void main() {
        // Sample noise — higher frequency so individual texels are visible as pixels
        vec2 noiseUv = vGlobalUv * 4.0 + vInstanceID.xy * 0.3;
        vec4 noise = texture2D(uNoiseTex, noiseUv);

        // Pattern 1: Blue/purple noise (Alche-style) — hard thresholds for crisp pixels
        vec3 faceColor = vec3(0.0);
        faceColor.r += step(0.5, noise.x);
        faceColor.g += step(0.3, noise.y);
        faceColor.b += step(0.1, noise.z);
        faceColor *= vec3(0.3, 0.4, 0.6) * 2.0;

        // Dim to keep tiles as background
        faceColor *= 0.15 + vInstanceID.z * 0.1;

        // Per-tile vignette
        float tileVignette = smoothstep(1.9, 0.1, length((vUv - 0.5) * 2.0));
        faceColor *= tileVignette;

        // Side faces: fluid emission
        vec4 fluids = texture2D(uFluidsTex, vGlobalUv);
        float fluidStrength = length(fluids.xy);
        vec3 sideColor = vec3(0.08, 0.09, 0.12);
        sideColor += 3.0 * fluidStrength;

        vec3 col = mix(sideColor, faceColor, vSideFace);

        // Halftone dots (CRT screen texture) — front faces only, sharp edges
        float dotw = step(length(fract(vGlobalUv * 1800.0 * 0.23) - 0.5), 0.35);
        dotw = mix(dotw, 1.0, 0.5) * 0.9;
        col *= mix(1.0, dotw, vSideFace);

        // Global vignette
        col *= smoothstep(0.55, 0.05, length(vGlobalUv - 0.5));

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    const tileMat = new THREE.ShaderMaterial({
      vertexShader: tileVertShader,
      fragmentShader: tileFragShader,
      uniforms: {
        uScale: { value: new THREE.Vector3(14, 10, 1) },
        uFluidsTex: { value: null },
        uNoiseTex: { value: noiseTex },
        uTime: { value: 0 },
      },
      side: THREE.DoubleSide,
    });

    const tileMesh = new THREE.Mesh(tileGeo, tileMat);
    scene.add(tileMesh);

    // ── Crosshairs at tile intersections ──

    // Collect unique corner positions from quad-tree tiles
    const cornerSet = new Set();
    const corners = [];
    for (const t of tiles) {
      const pts = [
        [t.x, t.y], [t.x + t.w, t.y],
        [t.x, t.y + t.h], [t.x + t.w, t.y + t.h],
      ];
      for (const [cx, cy] of pts) {
        const key = cx.toFixed(6) + ',' + cy.toFixed(6);
        if (!cornerSet.has(key)) {
          cornerSet.add(key);
          corners.push({ x: cx, y: cy });
        }
      }
    }

    // Instanced crosshair geometry (small plane per cross)
    const crossBase = new THREE.PlaneGeometry(1, 1);
    const crossGeo = new THREE.InstancedBufferGeometry();
    crossGeo.index = crossBase.index;
    crossGeo.attributes.position = crossBase.attributes.position;
    crossGeo.attributes.uv = crossBase.attributes.uv;
    crossGeo.attributes.normal = crossBase.attributes.normal;

    const crossPositions = new Float32Array(corners.length * 2);
    for (let i = 0; i < corners.length; i++) {
      crossPositions[i * 2] = corners[i].x;
      crossPositions[i * 2 + 1] = corners[i].y;
    }
    crossGeo.setAttribute('aCrossPos', new THREE.InstancedBufferAttribute(crossPositions, 2));
    crossGeo.instanceCount = corners.length;

    const crossVertShader = /* glsl */`
      attribute vec2 aCrossPos; // corner position in 0..1 UV
      uniform vec3 uScale;
      varying vec2 vUv;

      #define PI 3.14159265359

      mat2 rotate(float rad) {
        return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));
      }

      void main() {
        vUv = uv;

        // Corner in centered UV space
        float uvX = aCrossPos.x - 0.5;
        float uvY = aCrossPos.y - 0.5;
        float theta = uvX * PI;
        float radius = uScale.x * 0.5;

        // Small cross plane scaled to ~0.15 units
        vec3 localPos = position * 0.15;
        // Rotate to be tangent to cylinder surface
        localPos.xz *= rotate(-theta);

        // Place on cylinder at tile front face depth
        vec3 cylPos = vec3(
          sin(theta) * radius,
          uvY * uScale.y * 1.5,
          -cos(theta) * radius
        );

        vec3 pos = cylPos + localPos;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const crossFragShader = /* glsl */`
      varying vec2 vUv;

      void main() {
        // Render + shape from UV
        vec2 uv = vUv - 0.5;
        float armW = 0.03; // arm thickness
        float armL = 0.4;  // arm length
        float crossH = step(abs(uv.y), armW) * step(abs(uv.x), armL);
        float crossV = step(abs(uv.x), armW) * step(abs(uv.y), armL);
        float cross = max(crossH, crossV);
        if (cross < 0.5) discard;
        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.25);
      }
    `;

    const crossMat = new THREE.ShaderMaterial({
      vertexShader: crossVertShader,
      fragmentShader: crossFragShader,
      uniforms: {
        uScale: { value: new THREE.Vector3(14, 10, 1) },
      },
      transparent: true,
      depthWrite: false,
      side: THREE.DoubleSide,
    });
    scene.add(new THREE.Mesh(crossGeo, crossMat));

    // ── Glass shader (Alche-style custom refraction) ──
    const glassVertexShader = /* glsl */`
      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vViewPos;

      void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        vViewPos = mvPos.xyz;
        gl_Position = projectionMatrix * mvPos;
      }
    `;

    const glassFragmentShader = /* glsl */`
      #define PI 3.14159265359
      #define SAMPLES 8

      uniform sampler2D uTrnsTex;
      uniform vec2 uTrnsWinRes;
      uniform sampler2D uNoiseTex;
      uniform samplerCube uEnvMap;
      uniform sampler2D uFluidsTex;
      uniform float uRoughness;
      uniform float uNoiseScale;
      uniform vec3 uMaterialColor;
      uniform vec2 uMousePos;
      uniform float uMouseVelocity;

      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vViewPos;

      float random(vec2 p) {
        return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);
      }

      float ggx(float dNH, float roughness) {
        float a2 = roughness * roughness;
        a2 = a2 * a2;
        float dNH2 = dNH * dNH;
        if (dNH2 <= 0.0) return 0.0;
        return a2 / (PI * pow(dNH2 * (a2 - 1.0) + 1.0, 2.0));
      }

      float fresnel(float d) {
        float f0 = 0.1;
        return f0 + (1.0 - f0) * pow(1.0 - d, 5.0);
      }

      void main() {
        vec3 normal = normalize(vNormal);
        vec3 viewDir = normalize(-vViewPos);
        vec2 trnsUv = gl_FragCoord.xy / uTrnsWinRes;

        // Fluid micro-distortion on refraction UV
        vec4 fluids = texture2D(uFluidsTex, trnsUv);
        trnsUv += fluids.xy * 0.008;
        float fluidsLength = length(fluids.xy);

        // Mouse interactive refraction boost
        float mouseDist = distance(trnsUv, uMousePos);
        float mouseProximity = smoothstep(0.4, 0.0, mouseDist);
        float velocityBoost = uMouseVelocity;
        float proximityBoost = mouseProximity * 0.6;
        float totalBoost = max(velocityBoost, proximityBoost);

        // Noise-based roughness variation (frosted glass)
        vec4 noise = texture2D(uNoiseTex, vUv * uNoiseScale);
        vec4 noise2 = texture2D(uNoiseTex, vUv * 1.0 + (noise.xy - 0.5) * 2.0);
        float roughness = smoothstep(0.3, 0.8, noise2.y) * uRoughness;

        // Refraction normal (3D normal -> 2D screen offset)
        vec2 refractNormal = normal.xy * (1.0 - normal.z * 0.7);
        float refractPower = 0.15 * (1.0 + totalBoost * 2.0);
        float slideMultiplier = 1.0 + totalBoost * 3.0;
        vec2 refractUv = trnsUv;

        // Multi-sample refraction with chromatic aberration
        vec3 refractCol = vec3(0.0);
        for (int i = 0; i < SAMPLES; i++) {
          float slide = (0.01 + random(trnsUv + float(i) * 0.2) * 0.015) * slideMultiplier;
          vec2 roughnessDir = vec2(
            random(trnsUv + float(i) * 0.1) - 0.5,
            random(trnsUv + float(i) * 0.2) - 0.5
          ) * roughness * 0.3;

          vec2 refractUvR = roughnessDir + refractUv - refractNormal * (refractPower + slide * 1.0);
          vec2 refractUvG = roughnessDir + refractUv - refractNormal * (refractPower + slide * 2.0);
          vec2 refractUvB = roughnessDir + refractUv - refractNormal * (refractPower + slide * 4.0);

          refractCol.r += texture2D(uTrnsTex, refractUvR).r;
          refractCol.g += texture2D(uTrnsTex, refractUvG).g;
          refractCol.b += texture2D(uTrnsTex, refractUvB).b;
        }
        refractCol /= float(SAMPLES);

        vec3 c = refractCol;

        // Apply material color tint
        c *= uMaterialColor / 255.0;

        // GGX specular highlight
        vec3 lightDir = normalize(vec3(4.0, 4.0, 5.0) - vViewPos);
        vec3 halfVec = normalize(viewDir + lightDir);
        float dNH = max(dot(normal, halfVec), 0.0);
        float spec = ggx(dNH, 0.003 + roughness * 0.4);
        c += vec3(1.0) * spec * 0.6;

        // Second specular from opposite light
        vec3 lightDir2 = normalize(vec3(-5.0, -1.0, 4.0) - vViewPos);
        vec3 halfVec2 = normalize(viewDir + lightDir2);
        float dNH2 = max(dot(normal, halfVec2), 0.0);
        float spec2 = ggx(dNH2, 0.003 + roughness * 0.4);
        c += vec3(1.0) * spec2 * 0.3;

        // Fresnel + environment reflection (Alche-style blend)
        float F = fresnel(max(dot(viewDir, normal), 0.0));
        vec3 reflectDir = reflect(-viewDir, normal);
        vec3 envColor = textureCube(uEnvMap, reflectDir).rgb;
        c = mix(c, envColor, F * 0.5) + c * F * 0.15;

        // Brightness boost + fluid boost
        c *= 1.15;
        c *= 1.0 + fluidsLength * 2.0;

        gl_FragColor = vec4(c, 1.0);
      }
    `;

    // ── Environment CubeMap for reflections ──
    const cubeRT = new THREE.WebGLCubeRenderTarget(256, {
      format: THREE.RGBAFormat,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter,
    });
    const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRT);
    scene.add(cubeCamera);

    const glassMaterial = new THREE.ShaderMaterial({
      vertexShader: glassVertexShader,
      fragmentShader: glassFragmentShader,
      uniforms: {
        uTrnsTex: { value: backgroundRT.texture },
        uTrnsWinRes: { value: new THREE.Vector2(rtW, rtH) },
        uNoiseTex: { value: noiseTex },
        uEnvMap: { value: cubeRT.texture },
        uFluidsTex: { value: null },
        uRoughness: { value: 0.1 },
        uNoiseScale: { value: 9.0 },
        uMaterialColor: { value: new THREE.Vector3(255, 255, 255) },
        uMousePos: { value: new THREE.Vector2(0.5, 0.5) },
        uMouseVelocity: { value: 0.0 },
      },
      side: THREE.DoubleSide,
    });

    const logoGroup = new THREE.Group();
    scene.add(logoGroup);

    let envCaptured = false;

    new GLTFLoader().load('logo_black.glb', (gltf) => {
      const model = gltf.scene;
      const box = new THREE.Box3().setFromObject(model);
      const size = box.getSize(new THREE.Vector3());
      model.scale.setScalar(3.0 / Math.max(size.x, size.y, size.z));
      model.rotation.x = Math.PI / 2;

      const center = new THREE.Box3().setFromObject(model).getCenter(new THREE.Vector3());
      model.position.sub(center);

      model.traverse((child) => { if (child.isMesh) child.material = glassMaterial; });

      logoGroup.add(model);
      document.getElementById('loader').classList.add('hidden');
    });

    // ── "PromptHQ" text ──
    document.fonts.ready.then(() => {
      const c = document.createElement('canvas');
      c.width = 4096; c.height = 1024;
      const ctx = c.getContext('2d');
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let fs = 400;
      ctx.font = `700 ${fs}px StackSansText, system-ui, sans-serif`;
      fs = Math.round(fs * (c.width * 0.55) / ctx.measureText('PromptHQ').width);
      ctx.font = `700 ${fs}px StackSansText, system-ui, sans-serif`;

      ctx.save();
      ctx.shadowColor = 'rgba(255,255,255,0.4)';
      ctx.shadowBlur = 100;
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillText('PromptHQ', c.width / 2, c.height / 2);
      ctx.fillText('PromptHQ', c.width / 2, c.height / 2);
      ctx.restore();

      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillText('PromptHQ', c.width / 2, c.height / 2);

      const texture = new THREE.CanvasTexture(c);
      texture.minFilter = THREE.LinearFilter;
      texture.colorSpace = THREE.SRGBColorSpace;

      const dist = camera.position.z + 3;
      const visH = 2 * Math.tan(camera.fov * Math.PI / 360) * dist;
      const planeW = visH * camera.aspect * 0.85;
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(planeW, planeW / 4),
        new THREE.MeshBasicMaterial({ map: texture, transparent: true, depthWrite: false })
      );
      plane.position.z = -3;
      scene.add(plane);
    });

    // ── Lights ──
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const l1 = new THREE.PointLight(0xffffff, 5, 20);
    l1.position.set(4, 4, 5); scene.add(l1);
    const l2 = new THREE.PointLight(0xffe0cc, 3, 20);
    l2.position.set(-5, -1, 4); scene.add(l2);
    const l3 = new THREE.PointLight(0xffffff, 4, 15);
    l3.position.set(0, 2, -3); scene.add(l3);
    const dl = new THREE.DirectionalLight(0xffffff, 1);
    dl.position.set(0, 5, 5); scene.add(dl);

    // ── Mouse + animation ──
    let mx = 0, my = 0, tmx = 0, tmy = 0;
    let prevTmx = 0, prevTmy = 0;
    let mouseSpeed = 0, mouseVelocity = 0;

    addEventListener('mousemove', e => {
      tmx = (e.clientX / innerWidth) * 2 - 1;
      tmy = -(e.clientY / innerHeight) * 2 + 1;
    });

    const ENTRANCE_DURATION = 2.0;
    let startTime = null;

    function animate(timestamp) {
      requestAnimationFrame(animate);
      if (!startTime) startTime = timestamp;
      const elapsed = (timestamp - startTime) * 0.001;
      const deltaTime = prevAnimTime > 0 ? Math.min((timestamp - prevAnimTime) * 0.001, 0.05) : 0.016;
      prevAnimTime = timestamp;

      logoGroup.scale.setScalar(1 - Math.pow(1 - Math.min(elapsed / ENTRANCE_DURATION, 1), 3));

      tileMat.uniforms.uTime.value = elapsed;

      // 1. Smooth mouse + velocity tracking
      const dx = tmx - prevTmx;
      const dy = tmy - prevTmy;
      mouseSpeed = Math.sqrt(dx * dx + dy * dy);
      prevTmx = tmx; prevTmy = tmy;
      mouseVelocity += (mouseSpeed * 8.0 - mouseVelocity) * 0.1;
      mouseVelocity *= 0.95;
      mouseVelocity = Math.min(mouseVelocity, 1.0);

      mx += (tmx - mx) * 0.04;
      my += (tmy - my) * 0.04;

      // 2. Update glass interactive refraction uniforms
      glassMaterial.uniforms.uMousePos.value.set(
        (tmx + 1.0) * 0.5,
        (tmy + 1.0) * 0.5
      );
      glassMaterial.uniforms.uMouseVelocity.value = mouseVelocity;

      // 3. Fluid pointer tracking
      pointerPos.set((tmx + 1.0) * 0.5, (tmy + 1.0) * 0.5);
      const pdx = pointerPos.x - prevPointerPos.x;
      const pdy = pointerPos.y - prevPointerPos.y;
      // Non-linear accumulation with pow(1.6)
      const rawLen = Math.sqrt(pdx * pdx + pdy * pdy);
      const boosted = Math.pow(rawLen + 1.0, 1.6) - 1.0;
      const scale = rawLen > 0.0001 ? boosted / rawLen : 0;
      pointerVec.x += pdx * scale;
      pointerVec.y += pdy * scale;
      pointerVec.multiplyScalar(0.7); // decay per frame
      prevPointerPos.copy(pointerPos);

      // 4. Run fluid simulation passes
      const fluidDt = deltaTime;
      velocityMat.uniforms.dt.value = fluidDt;
      advectMat.uniforms.dt.value = fluidDt;

      // Pass 1: Curl
      curlMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(curlMat, curlRT);

      // Pass 2: Velocity (vorticity confinement + mouse)
      velocityMat.uniforms.dataTex.value = fluidRT_A.texture;
      velocityMat.uniforms.curlTex.value = curlRT.texture;
      runFluidPass(velocityMat, fluidRT_B);
      let tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Pass 3: Divergence
      divergenceMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(divergenceMat, fluidRT_B);
      tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Pass 4: Pressure (4 Jacobi iterations)
      for (let i = 0; i < 4; i++) {
        pressureMat.uniforms.dataTex.value = fluidRT_A.texture;
        runFluidPass(pressureMat, fluidRT_B);
        tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;
      }

      // Pass 5: Gradient subtract
      gradSubMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(gradSubMat, fluidRT_B);
      tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Pass 6: Advect
      advectMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(advectMat, fluidRT_B);
      tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Update fluid texture uniforms for downstream shaders
      tileMat.uniforms.uFluidsTex.value = fluidRT_A.texture;
      glassMaterial.uniforms.uFluidsTex.value = fluidRT_A.texture;

      renderer.setRenderTarget(null);

      // 5. Quaternion-based logo rotation
      // Accumulate mouse velocity as angular momentum
      hoverVelX -= dy * 0.03;
      hoverVelY += dx * 0.03;
      // Friction decay — 0.35 base: retains ~35% after 1s (strong inertia)
      const friction = Math.pow(0.35, deltaTime);
      hoverVelX *= friction;
      hoverVelY *= friction;
      // Apply incremental rotation from mouse velocity this frame
      tempEuler.set(hoverVelX, hoverVelY, 0);
      mouseRotQuat.setFromEuler(tempEuler);
      logoGroup.quaternion.premultiply(mouseRotQuat);
      // Slerp toward identity (gentle return to neutral pose)
      const returnForce = Math.min(0.15 * deltaTime, 1.0);
      logoGroup.quaternion.slerp(identityQuat, returnForce);
      // Continuous Z-axis auto-spin (always turning on itself)
      autoRotQuat.setFromAxisAngle(autoSpinAxis, 0.05 * deltaTime);
      logoGroup.quaternion.premultiply(autoRotQuat);
      // Gentle vertical float
      logoGroup.position.y = Math.sin(elapsed * 0.4) * 0.06;

      // Capture environment cubemap once (after first frame setup)
      if (!envCaptured && logoGroup.children.length > 0) {
        logoGroup.visible = false;
        cubeCamera.position.copy(logoGroup.position);
        cubeCamera.update(renderer, scene);
        logoGroup.visible = true;
        envCaptured = true;
      }

      // Two-pass rendering: background RT then final
      logoGroup.visible = false;
      renderer.setRenderTarget(backgroundRT);
      renderer.render(scene, camera);
      renderer.setRenderTarget(null);
      logoGroup.visible = true;

      renderer.render(scene, camera);
    }

    requestAnimationFrame(animate);
    setTimeout(() => document.getElementById('loader').classList.add('hidden'), 5000);

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);

      // Update render target size
      const newW = Math.floor(innerWidth * Math.min(devicePixelRatio, 2));
      const newH = Math.floor(innerHeight * Math.min(devicePixelRatio, 2));
      backgroundRT.setSize(newW, newH);
      glassMaterial.uniforms.uTrnsWinRes.value.set(newW, newH);

    });
  </script>
</body>
</html>
