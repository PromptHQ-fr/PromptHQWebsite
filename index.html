<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PromptHQ</title>
  <style>
    @font-face {
      font-family: 'StackSansText';
      src: url('StackSansText-VariableFont_wght.ttf') format('truetype');
      font-weight: 100 900;
      font-display: swap;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      background: #000000;
      overflow: hidden;
    }
    canvas { position: fixed; top: 0; left: 0; display: block; }
    .loader {
      position: fixed; inset: 0; background: #000000;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; transition: opacity 0.6s ease, visibility 0.6s ease;
    }
    .loader.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
    .loader-text {
      font-family: 'StackSansText', monospace, system-ui;
      font-size: 28px;
      font-weight: 700;
      letter-spacing: 6px;
      color: rgba(255,255,255,0.9);
    }
    .loader-text .char {
      display: inline-block;
      min-width: 0.6em;
      text-align: center;
    }
    .loader-text .char.glitch {
      color: #F82F02;
      text-shadow: 0 0 8px rgba(248,47,2,0.5);
    }
    .loader-text .char.resolved {
      color: rgba(255,255,255,0.9);
      text-shadow: none;
    }
    .loader-scanlines {
      position: fixed; inset: 0; pointer-events: none;
      background: repeating-linear-gradient(
        0deg, transparent, transparent 2px,
        rgba(0,0,0,0.12) 2px, rgba(0,0,0,0.12) 4px
      );
      z-index: 101; opacity: 0; transition: opacity 0.3s ease;
    }
    .loader-scanlines.active { opacity: 1; }
    .loader-cursor {
      display: inline-block; width: 2px; height: 1.1em;
      background: #F82F02; margin-left: 2px;
      vertical-align: text-bottom;
      animation: blink 0.6s step-end infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }
    .loader-sub {
      font-family: 'StackSansText', monospace, system-ui;
      font-size: 11px; font-weight: 500;
      letter-spacing: 3px; text-transform: uppercase;
      color: rgba(255,255,255,0.25);
      margin-top: 16px; opacity: 0; transition: opacity 0.4s ease;
    }
    .loader-sub.visible { opacity: 1; }

    .discord-widget {
      position: fixed;
      bottom: 33%;
      right: 160px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
      font-family: 'StackSansText', system-ui, sans-serif;
      transition: all 0.3s ease;
    }
    @media (max-width: 1400px) {
      .discord-widget {
        bottom: 24px;
        right: 24px;
      }
    }
    .discord-stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 26px;
      font-weight: 400;
      color: rgba(255,255,255,0.85);
    }
    .discord-stat .dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
    }
    .discord-stat .dot.green { background: #23a55a; }
    .discord-stat .dot.grey { background: rgba(255,255,255,0.5); }
    .discord-join {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      margin-top: 4px;
      font-size: 24px;
      font-weight: 400;
      color: rgba(255,255,255,0.7);
      text-decoration: none;
      transition: color 0.3s ease;
    }
    .discord-join svg {
      width: 24px;
      height: 24px;
      fill: currentColor;
    }
    .discord-desc {
      max-width: 280px;
      font-size: 12px;
      font-weight: 400;
      line-height: 1.5;
      color: rgba(255,255,255,0.35);
      text-align: right;
      margin-top: 4px;
    }
    .discord-join:hover { color: #fff; }

    @media (max-width: 768px) {
      .loader-text { font-size: 20px; letter-spacing: 3px; }
      .loader-sub { font-size: 10px; letter-spacing: 2px; }
      .discord-stat { font-size: 14px; }
      .discord-join { font-size: 13px; }
      .discord-join svg { width: 16px; height: 16px; }
      .discord-desc { font-size: 11px; }
    }
  </style>
</head>
<body>
  <div class="loader-scanlines" id="scanlines"></div>
  <div class="loader" id="loader">
    <div class="loader-text" id="glitch-text"></div>
    <div class="loader-sub" id="loader-sub">initializing</div>
  </div>

  <div class="discord-widget" id="discord-widget">
    <div class="discord-stat" id="stat-online" style="display:none"><span class="dot green"></span><span id="online-count"></span> online</div>
    <div class="discord-stat" id="stat-members" style="display:none"><span class="dot grey"></span><span id="member-count"></span> members</div>
    <div class="discord-desc" id="discord-desc" style="display:none"></div>
    <a href="https://discord.gg/xaBr8E235f" target="_blank" rel="noopener" class="discord-join">
      <svg viewBox="0 0 24 24"><path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.095 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.095 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/></svg>
      Join Discord
    </a>
  </div>
  <script>
    fetch('https://discord.com/api/v10/invites/xaBr8E235f?with_counts=true')
      .then(r => r.json())
      .then(d => {
        if (d.approximate_member_count) {
          document.getElementById('online-count').textContent = d.approximate_presence_count.toLocaleString();
          document.getElementById('member-count').textContent = d.approximate_member_count.toLocaleString();
          document.getElementById('stat-online').style.display = 'flex';
          document.getElementById('stat-members').style.display = 'flex';
        }
        if (d.guild && d.guild.description) {
          const desc = document.getElementById('discord-desc');
          desc.textContent = d.guild.description;
          desc.style.display = 'block';
        }
      })
      .catch(() => {});
  </script>

  <script>
    // Glitch text loader animation
    (function() {
      const target = 'PromptHQ';
      const glitchChars = '!@#$%^&*()_+-=[]{}|;:<>?/~0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      const el = document.getElementById('glitch-text');
      const sub = document.getElementById('loader-sub');
      const scanlines = document.getElementById('scanlines');
      const resolved = new Array(target.length).fill(false);
      // Build initial random chars
      function randomChar() { return glitchChars[Math.floor(Math.random() * glitchChars.length)]; }

      function render() {
        let html = '';
        for (let i = 0; i < target.length; i++) {
          if (resolved[i]) {
            html += '<span class="char resolved">' + target[i] + '</span>';
          } else {
            html += '<span class="char glitch">' + randomChar() + '</span>';
          }
        }
        html += '<span class="loader-cursor"></span>';
        el.innerHTML = html;
      }

      // Scramble unresolved chars every 50ms
      const scrambleInterval = setInterval(render, 50);

      // Resolve one random unresolved char every ~200ms
      let resolveCount = 0;
      function resolveNext() {
        const unresolved = [];
        for (let i = 0; i < target.length; i++) {
          if (!resolved[i]) unresolved.push(i);
        }
        if (unresolved.length === 0) {
          clearInterval(scrambleInterval);
          render();
          return;
        }
        const idx = unresolved[Math.floor(Math.random() * unresolved.length)];
        resolved[idx] = true;
        resolveCount++;
        render();
        // Accelerate toward the end
        const delay = 120 + Math.random() * 180 - resolveCount * 15;
        setTimeout(resolveNext, Math.max(40, delay));
      }

      // Start after short delay, show scanlines
      setTimeout(() => {
        scanlines.classList.add('active');
        sub.classList.add('visible');
        setTimeout(resolveNext, 300);
      }, 200);

      // Expose dismiss function for when scene is ready
      window._dismissLoader = function() {
        // Wait for text to finish resolving, then hide
        const check = setInterval(() => {
          if (resolved.every(Boolean)) {
            clearInterval(check);
            clearInterval(scrambleInterval);
            setTimeout(() => {
              document.getElementById('loader').classList.add('hidden');
              scanlines.classList.remove('active');
            }, 400);
          }
        }, 100);
        // Fallback: force hide after 2s regardless
        setTimeout(() => {
          clearInterval(check);
          clearInterval(scrambleInterval);
          document.getElementById('loader').classList.add('hidden');
          scanlines.classList.remove('active');
        }, 2000);
      };
    })();
  </script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || innerWidth < 768;
    const maxDPR = isMobile ? 1.5 : 2;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const mobileFov = innerWidth / innerHeight < 0.8 ? 55 : 40;
    const camera = new THREE.PerspectiveCamera(mobileFov, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 0, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, maxDPR));
    document.body.appendChild(renderer.domElement);

    // ── GPU Fluid Simulation (Navier-Stokes) ──
    const FLUID_SIZE = 128;
    const fluidOpts = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
      type: THREE.HalfFloatType,
      depthBuffer: false,
      stencilBuffer: false,
    };
    let fluidRT_A = new THREE.WebGLRenderTarget(FLUID_SIZE, FLUID_SIZE, fluidOpts);
    let fluidRT_B = new THREE.WebGLRenderTarget(FLUID_SIZE, FLUID_SIZE, fluidOpts);
    let curlRT = new THREE.WebGLRenderTarget(FLUID_SIZE, FLUID_SIZE, fluidOpts);

    const fluidQuadGeo = new THREE.PlaneGeometry(2, 2);
    const fluidOrtho = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    // Fluid pointer state
    const pointerPos = new THREE.Vector2(0.5, 0.5);
    const pointerVec = new THREE.Vector2(0, 0);
    const prevPointerPos = new THREE.Vector2(0.5, 0.5);

    // Common fluid vertex shader
    const fluidVertShader = /* glsl */`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `;

    // Pass 1: Curl (vorticity)
    const curlMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          float L = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).y;
          float R = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).y;
          float T = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).x;
          float B = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).x;
          float curl = (R - L) - (T - B);
          gl_FragColor = vec4(curl * 0.5 + 0.5, 0.0, 0.0, 1.0);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 2: Velocity (vorticity confinement + mouse injection)
    const velocityMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform sampler2D curlTex;
        uniform vec2 dataSize;
        uniform vec2 pointerPos;
        uniform vec2 pointerVec;
        uniform float dt;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          vec2 vel = data.xy;

          // Vorticity confinement
          float cL = texture2D(curlTex, (fc - vec2(1.0, 0.0)) / dataSize).x - 0.5;
          float cR = texture2D(curlTex, (fc + vec2(1.0, 0.0)) / dataSize).x - 0.5;
          float cT = texture2D(curlTex, (fc + vec2(0.0, 1.0)) / dataSize).x - 0.5;
          float cB = texture2D(curlTex, (fc - vec2(0.0, 1.0)) / dataSize).x - 0.5;
          float cC = texture2D(curlTex, uv).x - 0.5;

          vec2 force = vec2(abs(cT) - abs(cB), abs(cR) - abs(cL));
          float fLen = length(force);
          force = fLen > 0.0001 ? force / fLen : vec2(0.0);
          vel += force * cC * 0.15 * dt;

          // Mouse injection
          float pv = length(pointerVec);
          float splatRadius = 0.03 + 0.15 * min(1.0, pv);
          float dist = distance(uv, pointerPos);
          float splat = exp(-dist * dist / (splatRadius * splatRadius));
          vel += pointerVec * splat * 80.0 * dt;

          gl_FragColor = vec4(vel, data.zw);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        curlTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
        pointerPos: { value: pointerPos },
        pointerVec: { value: pointerVec },
        dt: { value: 0.016 },
      },
    });

    // Pass 3: Divergence (store in .w channel)
    const divergenceMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          float L = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).x;
          float R = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).x;
          float T = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).y;
          float B = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).y;
          float div = -0.5 * (R - L + T - B);
          gl_FragColor = vec4(data.xy, 0.0, div);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 4: Pressure (Jacobi iteration)
    const pressureMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          float pL = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).z;
          float pR = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).z;
          float pT = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).z;
          float pB = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).z;
          float pressure = (pL + pR + pT + pB + data.w) * 0.25;
          gl_FragColor = vec4(data.xy, pressure, data.w);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 5: Gradient Subtract
    const gradSubMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec4 data = texture2D(dataTex, uv);
          vec2 vel = data.xy;
          float pL = texture2D(dataTex, (fc - vec2(1.0, 0.0)) / dataSize).z;
          float pR = texture2D(dataTex, (fc + vec2(1.0, 0.0)) / dataSize).z;
          float pT = texture2D(dataTex, (fc + vec2(0.0, 1.0)) / dataSize).z;
          float pB = texture2D(dataTex, (fc - vec2(0.0, 1.0)) / dataSize).z;
          vel -= 0.5 * vec2(pR - pL, pT - pB);
          gl_FragColor = vec4(vel, data.zw);
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
      },
    });

    // Pass 6: Advect (Semi-Lagrangian)
    const advectMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D dataTex;
        uniform vec2 dataSize;
        uniform float dt;
        varying vec2 vUv;
        void main() {
          vec2 fc = gl_FragCoord.xy;
          vec2 uv = fc / dataSize;
          vec2 vel = texture2D(dataTex, uv).xy;
          vec2 prevUv = (fc - vel * dt * dataSize) / dataSize;
          vec4 result = texture2D(dataTex, prevUv);
          result.xy *= 0.995; // dissipation
          gl_FragColor = result;
        }
      `,
      uniforms: {
        dataTex: { value: null },
        dataSize: { value: new THREE.Vector2(FLUID_SIZE, FLUID_SIZE) },
        dt: { value: 0.016 },
      },
    });

    const fluidQuad = new THREE.Mesh(fluidQuadGeo, curlMat);
    const fluidScene = new THREE.Scene();
    fluidScene.add(fluidQuad);

    function runFluidPass(mat, output) {
      fluidQuad.material = mat;
      renderer.setRenderTarget(output);
      renderer.render(fluidScene, fluidOrtho);
    }

    // Quaternion rotation state
    const mouseRotQuat = new THREE.Quaternion();
    const autoSpinTarget = new THREE.Quaternion();
    const autoSpinAxis = new THREE.Vector3(0, 0, 1);
    const tempEuler = new THREE.Euler(0, 0, 0);
    let hoverVelX = 0, hoverVelY = 0;
    let autoSpinAngle = 0;
    let prevAnimTime = 0;

    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment()).texture;
    pmrem.dispose();

    // ── Render target for refraction (2-pass rendering) ──
    const rtW = Math.floor(innerWidth * Math.min(devicePixelRatio, maxDPR));
    const rtH = Math.floor(innerHeight * Math.min(devicePixelRatio, maxDPR));
    const backgroundRT = new THREE.WebGLRenderTarget(rtW, rtH, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
    });

    // ── Bloom pipeline render targets ──
    const sceneRT = new THREE.WebGLRenderTarget(rtW, rtH, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat,
    });

    let bw1 = Math.floor(rtW / 4), bh1 = Math.floor(rtH / 4);
    let bw2 = Math.floor(rtW / 8), bh2 = Math.floor(rtH / 8);
    let bw3 = Math.floor(rtW / 16), bh3 = Math.floor(rtH / 16);
    const bloomOpts = {
      minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat, type: THREE.HalfFloatType,
      depthBuffer: false, stencilBuffer: false,
    };

    const bloomBrightRT = new THREE.WebGLRenderTarget(bw1, bh1, bloomOpts);
    const bloom0H = new THREE.WebGLRenderTarget(bw1, bh1, bloomOpts);
    const bloom0V = new THREE.WebGLRenderTarget(bw1, bh1, bloomOpts);
    const bloom1H = new THREE.WebGLRenderTarget(bw2, bh2, bloomOpts);
    const bloom1V = new THREE.WebGLRenderTarget(bw2, bh2, bloomOpts);
    const bloom2H = new THREE.WebGLRenderTarget(bw3, bh3, bloomOpts);
    const bloom2V = new THREE.WebGLRenderTarget(bw3, bh3, bloomOpts);

    // ── Noise texture (256x256 random RGBA via Canvas2D) ──
    const noiseCanvas = document.createElement('canvas');
    noiseCanvas.width = noiseCanvas.height = 256;
    const noiseCtx = noiseCanvas.getContext('2d');
    const noiseData = noiseCtx.createImageData(256, 256);
    for (let i = 0; i < noiseData.data.length; i++) {
      noiseData.data[i] = Math.random() * 255;
    }
    noiseCtx.putImageData(noiseData, 0, 0);
    const noiseTex = new THREE.CanvasTexture(noiseCanvas);
    noiseTex.wrapS = noiseTex.wrapT = THREE.RepeatWrapping;
    noiseTex.magFilter = THREE.NearestFilter;
    noiseTex.minFilter = THREE.NearestFilter;

    // ── Logo texture for tile overlay (white text on transparent) ──
    const logoCanvas = document.createElement('canvas');
    logoCanvas.width = 1024; logoCanvas.height = 256;
    const logoCtx = logoCanvas.getContext('2d');
    logoCtx.clearRect(0, 0, 1024, 256);
    logoCtx.fillStyle = '#ffffff';
    logoCtx.textAlign = 'center';
    logoCtx.textBaseline = 'middle';
    logoCtx.font = '700 180px StackSansText, system-ui, sans-serif';
    logoCtx.fillText('PromptHQ', 512, 128);
    const logoTileTex = new THREE.CanvasTexture(logoCanvas);
    logoTileTex.wrapS = logoTileTex.wrapT = THREE.RepeatWrapping;
    logoTileTex.minFilter = THREE.LinearFilter;

    // ── BGQuadTree — Instanced cube tiles on a cylinder ──

    // Quad-tree subdivision: recursively split a rectangle into 4 children
    function buildQuadTree(x, y, w, h, depth, maxDepth, tiles) {
      // Random split probability decreases with depth
      const splitProb = [0.5, 0.3, 0.15, 0.05];
      if (depth >= maxDepth || Math.random() > (splitProb[depth] || 0.1)) {
        // Leaf node → emit a tile
        tiles.push({ x, y, w, h });
        return;
      }
      const hw = w / 2, hh = h / 2;
      buildQuadTree(x,      y,      hw, hh, depth + 1, maxDepth, tiles);
      buildQuadTree(x + hw, y,      hw, hh, depth + 1, maxDepth, tiles);
      buildQuadTree(x,      y + hh, hw, hh, depth + 1, maxDepth, tiles);
      buildQuadTree(x + hw, y + hh, hw, hh, depth + 1, maxDepth, tiles);
    }

    // Generate tiles over an 8×6 base grid
    const tiles = [];
    const baseCols = 8, baseRows = 6;
    for (let r = 0; r < baseRows; r++) {
      for (let c = 0; c < baseCols; c++) {
        buildQuadTree(c / baseCols, r / baseRows, 1 / baseCols, 1 / baseRows, 0, 2, tiles);
      }
    }

    // Build InstancedBufferGeometry from a BoxGeometry template
    const tileBox = new THREE.BoxGeometry(1, 1, 1);
    const tileGeo = new THREE.InstancedBufferGeometry();
    tileGeo.index = tileBox.index;
    tileGeo.attributes.position = tileBox.attributes.position;
    tileGeo.attributes.normal = tileBox.attributes.normal;
    tileGeo.attributes.uv = tileBox.attributes.uv;

    const instanceCount = tiles.length;
    const aPos = new Float32Array(instanceCount * 2);    // center in 0..1 UV space
    const aScale = new Float32Array(instanceCount * 2);  // size in 0..1 UV space
    const aRand = new Float32Array(instanceCount * 4);   // random per-instance IDs

    for (let i = 0; i < instanceCount; i++) {
      const t = tiles[i];
      aPos[i * 2]     = t.x + t.w * 0.5;  // center X (0..1)
      aPos[i * 2 + 1] = t.y + t.h * 0.5;  // center Y (0..1)
      aScale[i * 2]     = t.w;
      aScale[i * 2 + 1] = t.h;
      aRand[i * 4]     = Math.random();
      aRand[i * 4 + 1] = Math.random();
      aRand[i * 4 + 2] = Math.random();
      aRand[i * 4 + 3] = Math.random();
    }

    tileGeo.setAttribute('aPos',   new THREE.InstancedBufferAttribute(aPos, 2));
    tileGeo.setAttribute('aScale', new THREE.InstancedBufferAttribute(aScale, 2));
    tileGeo.setAttribute('aRand',  new THREE.InstancedBufferAttribute(aRand, 4));
    tileGeo.instanceCount = instanceCount;

    // Tile vertex shader — cylindrical wrapping matching the grid
    const tileVertShader = /* glsl */`
      attribute vec2 aPos;    // tile center in 0..1
      attribute vec2 aScale;  // tile size in 0..1
      attribute vec4 aRand;   // random per-instance

      uniform vec3 uScale;    // same as grid: vec3(14, 10, 1)

      varying vec2 vUv;
      varying vec2 vGlobalUv;
      varying float vSideFace;
      varying vec4 vInstanceID;

      #define PI 3.14159265359

      void main() {
        vUv = uv;
        vInstanceID = aRand;

        // Local vertex in box [-0.5..0.5]
        vec3 localV = position;

        // Detect side face: front/back faces have |normal.z| close to 1
        vSideFace = step(0.5, abs(normal.z));

        // Scale box to tile size (in 0..1 UV -> world units)
        // Gap between tiles: shrink slightly (0.92 keeps a visible gap)
        float gap = 0.92;
        float tileW = aScale.x * gap;
        float tileH = aScale.y * gap;
        float tileDepth = min(aScale.x, aScale.y) * 0.8; // depth proportional to smallest dim

        localV.x *= tileW;
        localV.y *= tileH;
        localV.z *= tileDepth;

        // Position in 0..1 UV space -> -0.5..0.5 centered
        float uvX = aPos.x + localV.x - 0.5;
        float uvY = aPos.y + localV.y - 0.5;

        // Global UV for later use
        vGlobalUv = vec2(aPos.x + localV.x, aPos.y + localV.y);

        // Cylindrical wrap (matching grid: theta = localPos.x * PI)
        float theta = uvX * PI;
        float radius = uScale.x * 0.5;
        float depth = localV.z; // front/back offset

        vec3 pos = vec3(
          sin(theta) * (radius + depth),
          uvY * uScale.y * 1.5,
          -cos(theta) * (radius + depth)
        );

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    // Tile fragment shader — 3 animated patterns + halftone + fluid emission
    const tileFragShader = /* glsl */`
      varying vec2 vUv;
      varying vec2 vGlobalUv;
      varying float vSideFace;
      varying vec4 vInstanceID;
      uniform sampler2D uFluidsTex;
      uniform sampler2D uNoiseTex;
      uniform sampler2D uLogoTex;
      uniform float uTime;

      void main() {
        // Animated noise UV — scroll direction per tile based on vInstanceID
        vec2 noiseUv = vGlobalUv * 4.0 + vInstanceID.xy * 0.3;
        // Some tiles scroll horizontally, others vertically
        float scrollDir = step(0.5, vInstanceID.w);
        noiseUv.x += uTime * 0.08 * scrollDir * (vInstanceID.x - 0.5) * 2.0;
        noiseUv.y += uTime * 0.08 * (1.0 - scrollDir) * (vInstanceID.y - 0.5) * 2.0;

        vec4 noise = texture2D(uNoiseTex, noiseUv);

        // Select pattern type: 3 patterns split by vInstanceID.x
        float patternId = floor(vInstanceID.x * 3.0); // 0, 1, or 2

        vec3 faceColor = vec3(0.0);

        // Brand colors: woodsmoke #F82F02, scarlet #FF9054, jaffa #FFC0A4
        vec3 woodsmoke = vec3(0.973, 0.184, 0.008); // #F82F02
        vec3 scarlet   = vec3(1.0, 0.565, 0.329);   // #FF9054
        vec3 jaffa     = vec3(1.0, 0.753, 0.643);   // #FFC0A4

        if (patternId < 1.0) {
          // Pattern 1: Orange noise
          faceColor.r += step(0.3, noise.x);
          faceColor.g += step(0.5, noise.y);
          faceColor.b += step(0.7, noise.z);
          faceColor *= woodsmoke;
        } else if (patternId < 2.0) {
          // Pattern 2: Binary red/black grid
          float w = fract(noise.w * 9.0);
          w = step(0.5, w);
          faceColor = mix(vec3(0.0), woodsmoke, w);
        } else {
          // Pattern 3: Red gradient (woodsmoke → scarlet)
          vec3 c = woodsmoke;
          c = mix(c, scarlet, step(0.5, noise.w));
          c = mix(c, woodsmoke * 1.2, step(0.7, noise.y));
          faceColor = c;
        }

        // Tile brightness
        faceColor *= 0.35 + vInstanceID.z * 0.15;

        // Logo overlay — 3 display modes spanning across tiles (Alche-style)
        float logoMode = floor(vInstanceID.y * 3.0); // 0, 1, or 2
        vec2 logoUv = vec2(0.0);
        float aspect = 1024.0 / 256.0; // logo texture aspect ratio

        if (logoMode < 1.0) {
          // Mode 0: Tiled scrolling — rows shift with sin()
          logoUv = vGlobalUv;
          logoUv -= 0.5;
          logoUv.y *= aspect;
          logoUv += 0.5;
          vec2 tileUv = logoUv * 2.0;
          tileUv.x += sin(floor(tileUv.y) * 3.0 + uTime * 0.5) * 0.15;
          logoUv = fract(tileUv) * 1.3;
        } else if (logoMode < 2.0) {
          // Mode 1: Single horizontal scroll
          logoUv = vGlobalUv;
          logoUv -= 0.5;
          logoUv.y *= aspect;
          logoUv *= 1.1;
          logoUv += 0.5;
          vec2 tileUv = logoUv;
          tileUv.x += uTime * 0.06;
          logoUv = fract(tileUv);
        } else {
          // Mode 2: Vertical scroll per instance
          logoUv = vUv;
          logoUv -= 0.5;
          logoUv.x /= aspect;
          logoUv += 0.5;
          logoUv.y -= uTime * 0.3 * vInstanceID.x;
          logoUv.y = fract(logoUv.y);
          logoUv -= 0.5;
          logoUv *= 1.3 + vInstanceID.z * 3.0;
          logoUv += 0.5;
          logoUv.x -= 0.38;
          if (logoUv.x > 0.24 || logoUv.x < 0.0 || logoUv.y > 1.0 || logoUv.y < 0.0) {
            logoUv = vec2(0.0);
          }
        }

        vec4 logo = texture2D(uLogoTex, logoUv);
        float logoW = step(0.5, logo.a) * step(0.0, logoUv.y) * step(logoUv.y, 1.0);
        // Flicker: per-tile random frequency + sin(uTime)
        float flicker = step(0.3, sin(uTime * (2.0 + vInstanceID.w * 8.0) + vInstanceID.x * 6.28));
        faceColor += logoW * 0.25 * flicker;

        // Per-tile vignette
        float tileVignette = smoothstep(1.9, 0.1, length((vUv - 0.5) * 2.0));
        faceColor *= tileVignette;

        // Side faces: fluid emission
        vec4 fluids = texture2D(uFluidsTex, vGlobalUv);
        float fluidStrength = length(fluids.xy);
        vec3 sideColor = vec3(0.08, 0.09, 0.12);
        sideColor += 3.0 * fluidStrength;

        vec3 col = mix(sideColor, faceColor, vSideFace);

        // Halftone dots (CRT screen texture) — front faces only, sharp edges
        float dotw = step(length(fract(vGlobalUv * 1800.0 * 0.23) - 0.5), 0.35);
        dotw = mix(dotw, 1.0, 0.5) * 0.9;
        col *= mix(1.0, dotw, vSideFace);

        // Global vignette
        col *= smoothstep(0.55, 0.05, length(vGlobalUv - 0.5));

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    const tileMat = new THREE.ShaderMaterial({
      vertexShader: tileVertShader,
      fragmentShader: tileFragShader,
      uniforms: {
        uScale: { value: new THREE.Vector3(14, 10, 1) },
        uFluidsTex: { value: null },
        uNoiseTex: { value: noiseTex },
        uLogoTex: { value: logoTileTex },
        uTime: { value: 0 },
      },
      side: THREE.DoubleSide,
    });

    const tileMesh = new THREE.Mesh(tileGeo, tileMat);
    scene.add(tileMesh);

    // ── Crosshairs at tile intersections ──

    // Collect unique corner positions from quad-tree tiles
    const cornerSet = new Set();
    const corners = [];
    for (const t of tiles) {
      const pts = [
        [t.x, t.y], [t.x + t.w, t.y],
        [t.x, t.y + t.h], [t.x + t.w, t.y + t.h],
      ];
      for (const [cx, cy] of pts) {
        const key = cx.toFixed(6) + ',' + cy.toFixed(6);
        if (!cornerSet.has(key)) {
          cornerSet.add(key);
          corners.push({ x: cx, y: cy });
        }
      }
    }

    // Instanced crosshair geometry (small plane per cross)
    const crossBase = new THREE.PlaneGeometry(1, 1);
    const crossGeo = new THREE.InstancedBufferGeometry();
    crossGeo.index = crossBase.index;
    crossGeo.attributes.position = crossBase.attributes.position;
    crossGeo.attributes.uv = crossBase.attributes.uv;
    crossGeo.attributes.normal = crossBase.attributes.normal;

    const crossPositions = new Float32Array(corners.length * 2);
    for (let i = 0; i < corners.length; i++) {
      crossPositions[i * 2] = corners[i].x;
      crossPositions[i * 2 + 1] = corners[i].y;
    }
    crossGeo.setAttribute('aCrossPos', new THREE.InstancedBufferAttribute(crossPositions, 2));
    crossGeo.instanceCount = corners.length;

    const crossVertShader = /* glsl */`
      attribute vec2 aCrossPos; // corner position in 0..1 UV
      uniform vec3 uScale;
      varying vec2 vUv;

      #define PI 3.14159265359

      mat2 rotate(float rad) {
        return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));
      }

      void main() {
        vUv = uv;

        // Corner in centered UV space
        float uvX = aCrossPos.x - 0.5;
        float uvY = aCrossPos.y - 0.5;
        float theta = uvX * PI;
        float radius = uScale.x * 0.5;

        // Small cross plane scaled to ~0.15 units
        vec3 localPos = position * 0.15;
        // Rotate to be tangent to cylinder surface
        localPos.xz *= rotate(-theta);

        // Place on cylinder at tile front face depth
        vec3 cylPos = vec3(
          sin(theta) * radius,
          uvY * uScale.y * 1.5,
          -cos(theta) * radius
        );

        vec3 pos = cylPos + localPos;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const crossFragShader = /* glsl */`
      varying vec2 vUv;

      void main() {
        // Render + shape from UV
        vec2 uv = vUv - 0.5;
        float armW = 0.03; // arm thickness
        float armL = 0.4;  // arm length
        float crossH = step(abs(uv.y), armW) * step(abs(uv.x), armL);
        float crossV = step(abs(uv.x), armW) * step(abs(uv.y), armL);
        float cross = max(crossH, crossV);
        if (cross < 0.5) discard;
        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.25);
      }
    `;

    const crossMat = new THREE.ShaderMaterial({
      vertexShader: crossVertShader,
      fragmentShader: crossFragShader,
      uniforms: {
        uScale: { value: new THREE.Vector3(14, 10, 1) },
      },
      transparent: true,
      depthWrite: false,
      side: THREE.DoubleSide,
    });
    scene.add(new THREE.Mesh(crossGeo, crossMat));

    // ── Glass shader (Alche-style custom refraction) ──
    const glassVertexShader = /* glsl */`
      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vViewPos;

      void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
        vViewPos = mvPos.xyz;
        gl_Position = projectionMatrix * mvPos;
      }
    `;

    const glassFragmentShader = /* glsl */`
      #define PI 3.14159265359
      #define SAMPLES 8

      uniform sampler2D uTrnsTex;
      uniform vec2 uTrnsWinRes;
      uniform sampler2D uNoiseTex;
      uniform samplerCube uEnvMap;
      uniform sampler2D uFluidsTex;
      uniform float uRoughness;
      uniform float uNoiseScale;
      uniform vec3 uMaterialColor;
      uniform vec2 uMousePos;
      uniform float uMouseVelocity;

      varying vec2 vUv;
      varying vec3 vNormal;
      varying vec3 vViewPos;

      float random(vec2 p) {
        return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);
      }

      float ggx(float dNH, float roughness) {
        float a2 = roughness * roughness;
        a2 = a2 * a2;
        float dNH2 = dNH * dNH;
        if (dNH2 <= 0.0) return 0.0;
        return a2 / (PI * pow(dNH2 * (a2 - 1.0) + 1.0, 2.0));
      }

      float fresnel(float d) {
        float f0 = 0.1;
        return f0 + (1.0 - f0) * pow(1.0 - d, 5.0);
      }

      void main() {
        vec3 normal = normalize(vNormal);
        vec3 viewDir = normalize(-vViewPos);
        vec2 trnsUv = gl_FragCoord.xy / uTrnsWinRes;

        // Fluid micro-distortion on refraction UV
        vec4 fluids = texture2D(uFluidsTex, trnsUv);
        trnsUv += fluids.xy * 0.008;
        float fluidsLength = length(fluids.xy);

        // Mouse interactive refraction boost
        float mouseDist = distance(trnsUv, uMousePos);
        float mouseProximity = smoothstep(0.4, 0.0, mouseDist);
        float velocityBoost = uMouseVelocity;
        float proximityBoost = mouseProximity * 0.6;
        float totalBoost = max(velocityBoost, proximityBoost);

        // Noise-based roughness variation (frosted glass)
        vec4 noise = texture2D(uNoiseTex, vUv * uNoiseScale);
        vec4 noise2 = texture2D(uNoiseTex, vUv * 1.0 + (noise.xy - 0.5) * 2.0);
        float roughness = smoothstep(0.3, 0.8, noise2.y) * uRoughness;

        // Refraction normal (3D normal -> 2D screen offset)
        vec2 refractNormal = normal.xy * (1.0 - normal.z * 0.7);
        float refractPower = 0.15 * (1.0 + totalBoost * 2.0);
        float slideMultiplier = 1.0 + totalBoost * 3.0;
        vec2 refractUv = trnsUv;

        // Multi-sample refraction with chromatic aberration
        vec3 refractCol = vec3(0.0);
        for (int i = 0; i < SAMPLES; i++) {
          float slide = (0.01 + random(trnsUv + float(i) * 0.2) * 0.015) * slideMultiplier;
          vec2 roughnessDir = vec2(
            random(trnsUv + float(i) * 0.1) - 0.5,
            random(trnsUv + float(i) * 0.2) - 0.5
          ) * roughness * 0.3;

          vec2 refractUvR = roughnessDir + refractUv - refractNormal * (refractPower + slide * 1.0);
          vec2 refractUvG = roughnessDir + refractUv - refractNormal * (refractPower + slide * 2.0);
          vec2 refractUvB = roughnessDir + refractUv - refractNormal * (refractPower + slide * 4.0);

          refractCol.r += texture2D(uTrnsTex, refractUvR).r;
          refractCol.g += texture2D(uTrnsTex, refractUvG).g;
          refractCol.b += texture2D(uTrnsTex, refractUvB).b;
        }
        refractCol /= float(SAMPLES);

        vec3 c = refractCol;

        // Apply material color tint
        c *= uMaterialColor / 255.0;

        // GGX specular highlight
        vec3 lightDir = normalize(vec3(4.0, 4.0, 5.0) - vViewPos);
        vec3 halfVec = normalize(viewDir + lightDir);
        float dNH = max(dot(normal, halfVec), 0.0);
        float spec = ggx(dNH, 0.003 + roughness * 0.4);
        c += vec3(1.0) * spec * 0.6;

        // Second specular from opposite light
        vec3 lightDir2 = normalize(vec3(-5.0, -1.0, 4.0) - vViewPos);
        vec3 halfVec2 = normalize(viewDir + lightDir2);
        float dNH2 = max(dot(normal, halfVec2), 0.0);
        float spec2 = ggx(dNH2, 0.003 + roughness * 0.4);
        c += vec3(1.0) * spec2 * 0.3;

        // Fresnel + environment reflection (Alche-style blend)
        float F = fresnel(max(dot(viewDir, normal), 0.0));
        vec3 reflectDir = reflect(-viewDir, normal);
        vec3 envColor = textureCube(uEnvMap, reflectDir).rgb;
        c = mix(c, envColor, F * 0.5) + c * F * 0.15;

        // Brightness boost + fluid boost
        c *= 1.15;
        c *= 1.0 + fluidsLength * 2.0;

        gl_FragColor = vec4(c, 1.0);
      }
    `;

    // ── Environment CubeMap for reflections ──
    const cubeRT = new THREE.WebGLCubeRenderTarget(256, {
      format: THREE.RGBAFormat,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter,
    });
    const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRT);
    scene.add(cubeCamera);

    const glassMaterial = new THREE.ShaderMaterial({
      vertexShader: glassVertexShader,
      fragmentShader: glassFragmentShader,
      uniforms: {
        uTrnsTex: { value: backgroundRT.texture },
        uTrnsWinRes: { value: new THREE.Vector2(rtW, rtH) },
        uNoiseTex: { value: noiseTex },
        uEnvMap: { value: cubeRT.texture },
        uFluidsTex: { value: null },
        uRoughness: { value: 0.1 },
        uNoiseScale: { value: 9.0 },
        uMaterialColor: { value: new THREE.Vector3(255, 255, 255) },
        uMousePos: { value: new THREE.Vector2(0.5, 0.5) },
        uMouseVelocity: { value: 0.0 },
      },
      side: THREE.DoubleSide,
    });

    const logoGroup = new THREE.Group();
    scene.add(logoGroup);

    let envCaptured = false;

    new GLTFLoader().load('logo_black.glb', (gltf) => {
      const model = gltf.scene;
      const box = new THREE.Box3().setFromObject(model);
      const size = box.getSize(new THREE.Vector3());
      model.scale.setScalar((isMobile ? 2.55 : 3.0) / Math.max(size.x, size.y, size.z));
      model.rotation.x = Math.PI / 2;

      const center = new THREE.Box3().setFromObject(model).getCenter(new THREE.Vector3());
      model.position.sub(center);

      model.traverse((child) => { if (child.isMesh) child.material = glassMaterial; });

      logoGroup.add(model);
      if (window._dismissLoader) window._dismissLoader();
    });

    // ── "PromptHQ" text ──
    document.fonts.ready.then(() => {
      const c = document.createElement('canvas');
      const textScale = isMobile ? 0.5 : 1;
      c.width = 4096 * textScale; c.height = 1024 * textScale;
      const ctx = c.getContext('2d');
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let fs = 400;
      ctx.font = `700 ${fs}px StackSansText, system-ui, sans-serif`;
      fs = Math.round(fs * (c.width * 0.55) / ctx.measureText('PromptHQ').width);
      ctx.font = `700 ${fs}px StackSansText, system-ui, sans-serif`;

      ctx.save();
      ctx.shadowColor = 'rgba(255,255,255,0.4)';
      ctx.shadowBlur = 100;
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillText('PromptHQ', c.width / 2, c.height / 2);
      ctx.fillText('PromptHQ', c.width / 2, c.height / 2);
      ctx.restore();

      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillText('PromptHQ', c.width / 2, c.height / 2);

      const texture = new THREE.CanvasTexture(c);
      texture.minFilter = THREE.LinearFilter;
      texture.colorSpace = THREE.SRGBColorSpace;

      const dist = camera.position.z + 3;
      const visH = 2 * Math.tan(camera.fov * Math.PI / 360) * dist;
      const titleScale = isMobile ? 0.9775 : 0.85;
      const planeW = Math.min(visH * camera.aspect * titleScale, 10);
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(planeW, planeW / 4),
        new THREE.MeshBasicMaterial({ map: texture, transparent: true, depthWrite: false })
      );
      plane.position.z = -3;
      scene.add(plane);
    });

    // ── Lights ──
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const l1 = new THREE.PointLight(0xffffff, 5, 20);
    l1.position.set(4, 4, 5); scene.add(l1);
    const l2 = new THREE.PointLight(0xffe0cc, 3, 20);
    l2.position.set(-5, -1, 4); scene.add(l2);
    const l3 = new THREE.PointLight(0xffffff, 4, 15);
    l3.position.set(0, 2, -3); scene.add(l3);
    const dl = new THREE.DirectionalLight(0xffffff, 1);
    dl.position.set(0, 5, 5); scene.add(dl);

    // ── Bloom shaders & materials ──
    // Bright extraction (Alche-style: threshold + multiply)
    const bloomBrightMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D uSceneTex;
        uniform float uThreshold;
        varying vec2 vUv;
        void main() {
          vec4 c = texture2D(uSceneTex, vUv);
          vec3 f = max(vec3(0.0), c.rgb - uThreshold);
          gl_FragColor = vec4(c.rgb * f, 1.0);
        }
      `,
      uniforms: {
        uSceneTex: { value: null },
        uThreshold: { value: 0.35 },
      },
    });

    // Separable Gaussian blur (5-tap, offset * 2.0 for wider spread)
    const bloomBlurMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D uBloomTex;
        uniform vec2 uResolution;
        uniform bool uIsVertical;
        varying vec2 vUv;
        void main() {
          float w0 = 0.227027, w1 = 0.1945946, w2 = 0.1216216, w3 = 0.054054, w4 = 0.016216;
          vec3 sum = w0 * texture2D(uBloomTex, vUv).rgb;
          vec2 d1 = (uIsVertical ? vec2(0.0, 1.0) : vec2(1.0, 0.0)) * 2.0;
          vec2 d2 = d1 * 2.0;
          vec2 d3 = d1 * 3.0;
          vec2 d4 = d1 * 4.0;
          sum += w1 * (texture2D(uBloomTex, vUv + d1 / uResolution).rgb + texture2D(uBloomTex, vUv - d1 / uResolution).rgb);
          sum += w2 * (texture2D(uBloomTex, vUv + d2 / uResolution).rgb + texture2D(uBloomTex, vUv - d2 / uResolution).rgb);
          sum += w3 * (texture2D(uBloomTex, vUv + d3 / uResolution).rgb + texture2D(uBloomTex, vUv - d3 / uResolution).rgb);
          sum += w4 * (texture2D(uBloomTex, vUv + d4 / uResolution).rgb + texture2D(uBloomTex, vUv - d4 / uResolution).rgb);
          gl_FragColor = vec4(sum, 1.0);
        }
      `,
      uniforms: {
        uBloomTex: { value: null },
        uResolution: { value: new THREE.Vector2() },
        uIsVertical: { value: false },
      },
    });

    // Composite: scene + 3 bloom levels (Alche weights + uBoost)
    const bloomCompositeMat = new THREE.ShaderMaterial({
      vertexShader: fluidVertShader,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D uSceneTex;
        uniform sampler2D uBloom0;
        uniform sampler2D uBloom1;
        uniform sampler2D uBloom2;
        uniform float uBoost;
        varying vec2 vUv;
        void main() {
          vec3 col = texture2D(uSceneTex, vUv).rgb;
          col += texture2D(uBloom0, vUv).rgb * 0.3;
          col += texture2D(uBloom1, vUv).rgb * 0.5;
          col += texture2D(uBloom2, vUv).rgb * 0.8;
          col *= uBoost;
          gl_FragColor = vec4(col, 1.0);
        }
      `,
      uniforms: {
        uSceneTex: { value: null },
        uBloom0: { value: null },
        uBloom1: { value: null },
        uBloom2: { value: null },
        uBoost: { value: isMobile ? 1.5 : 1.15 },
      },
    });

    function runBloomPass(mat, target) {
      fluidQuad.material = mat;
      renderer.setRenderTarget(target);
      renderer.render(fluidScene, fluidOrtho);
    }

    function runBlurLevel(input, hTarget, vTarget, w, h) {
      bloomBlurMat.uniforms.uBloomTex.value = input.texture;
      bloomBlurMat.uniforms.uResolution.value.set(w, h);
      bloomBlurMat.uniforms.uIsVertical.value = false;
      runBloomPass(bloomBlurMat, hTarget);
      bloomBlurMat.uniforms.uBloomTex.value = hTarget.texture;
      bloomBlurMat.uniforms.uIsVertical.value = true;
      runBloomPass(bloomBlurMat, vTarget);
    }

    // ── Mouse + animation ──
    let tmx = 0, tmy = 0;
    let prevTmx = 0, prevTmy = 0;
    let mouseSpeed = 0, mouseVelocity = 0;

    addEventListener('mousemove', e => {
      tmx = (e.clientX / innerWidth) * 2 - 1;
      tmy = -(e.clientY / innerHeight) * 2 + 1;
    });

    // Touch support for mobile
    addEventListener('touchstart', e => { e.preventDefault(); }, { passive: false });
    addEventListener('touchmove', e => {
      e.preventDefault();
      const t = e.touches[0];
      tmx = (t.clientX / innerWidth) * 2 - 1;
      tmy = -(t.clientY / innerHeight) * 2 + 1;
    }, { passive: false });

    const ENTRANCE_DURATION = 2.0;
    let startTime = null;

    function animate(timestamp) {
      requestAnimationFrame(animate);
      if (!startTime) startTime = timestamp;
      const elapsed = (timestamp - startTime) * 0.001;
      const deltaTime = prevAnimTime > 0 ? Math.min((timestamp - prevAnimTime) * 0.001, 0.05) : 0.016;
      prevAnimTime = timestamp;

      logoGroup.scale.setScalar(1 - Math.pow(1 - Math.min(elapsed / ENTRANCE_DURATION, 1), 3));

      tileMat.uniforms.uTime.value = elapsed;

      // 1. Smooth mouse + velocity tracking
      const dx = tmx - prevTmx;
      const dy = tmy - prevTmy;
      mouseSpeed = Math.sqrt(dx * dx + dy * dy);
      prevTmx = tmx; prevTmy = tmy;
      mouseVelocity += (mouseSpeed * 8.0 - mouseVelocity) * 0.1;
      mouseVelocity *= 0.95;
      mouseVelocity = Math.min(mouseVelocity, 1.0);

      // 2. Update glass interactive refraction uniforms
      glassMaterial.uniforms.uMousePos.value.set(
        (tmx + 1.0) * 0.5,
        (tmy + 1.0) * 0.5
      );
      glassMaterial.uniforms.uMouseVelocity.value = mouseVelocity;

      // 3. Fluid pointer tracking
      pointerPos.set((tmx + 1.0) * 0.5, (tmy + 1.0) * 0.5);
      const pdx = pointerPos.x - prevPointerPos.x;
      const pdy = pointerPos.y - prevPointerPos.y;
      // Non-linear accumulation with pow(1.6)
      const rawLen = Math.sqrt(pdx * pdx + pdy * pdy);
      const boosted = Math.pow(rawLen + 1.0, 1.6) - 1.0;
      const scale = rawLen > 0.0001 ? boosted / rawLen : 0;
      pointerVec.x += pdx * scale;
      pointerVec.y += pdy * scale;
      pointerVec.multiplyScalar(0.7); // decay per frame
      prevPointerPos.copy(pointerPos);

      // 4. Run fluid simulation passes
      velocityMat.uniforms.dt.value = deltaTime;
      advectMat.uniforms.dt.value = deltaTime;

      // Pass 1: Curl
      curlMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(curlMat, curlRT);

      // Pass 2: Velocity (vorticity confinement + mouse)
      velocityMat.uniforms.dataTex.value = fluidRT_A.texture;
      velocityMat.uniforms.curlTex.value = curlRT.texture;
      runFluidPass(velocityMat, fluidRT_B);
      let tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Pass 3: Divergence
      divergenceMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(divergenceMat, fluidRT_B);
      tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Pass 4: Pressure (4 Jacobi iterations)
      for (let i = 0; i < 4; i++) {
        pressureMat.uniforms.dataTex.value = fluidRT_A.texture;
        runFluidPass(pressureMat, fluidRT_B);
        tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;
      }

      // Pass 5: Gradient subtract
      gradSubMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(gradSubMat, fluidRT_B);
      tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Pass 6: Advect
      advectMat.uniforms.dataTex.value = fluidRT_A.texture;
      runFluidPass(advectMat, fluidRT_B);
      tmp = fluidRT_A; fluidRT_A = fluidRT_B; fluidRT_B = tmp;

      // Update fluid texture uniforms for downstream shaders
      tileMat.uniforms.uFluidsTex.value = fluidRT_A.texture;
      glassMaterial.uniforms.uFluidsTex.value = fluidRT_A.texture;

      // 5. Quaternion-based logo rotation
      // Advance auto-spin target (always accumulating, never reset)
      autoSpinAngle += 0.085 * deltaTime;
      autoSpinTarget.setFromAxisAngle(autoSpinAxis, autoSpinAngle);
      // Accumulate mouse velocity as angular momentum
      hoverVelX -= dy * 0.03;
      hoverVelY += dx * 0.03;
      // Friction decay — 0.35 base: retains ~35% after 1s (strong inertia)
      const friction = Math.pow(0.35, deltaTime);
      hoverVelX *= friction;
      hoverVelY *= friction;
      // Apply incremental rotation from mouse velocity this frame
      tempEuler.set(hoverVelX, hoverVelY, 0);
      mouseRotQuat.setFromEuler(tempEuler);
      logoGroup.quaternion.premultiply(mouseRotQuat);
      // Slerp toward the spinning target (not identity — preserves auto-spin)
      const returnForce = Math.min(0.15 * deltaTime, 1.0);
      logoGroup.quaternion.slerp(autoSpinTarget, returnForce);
      // Gentle vertical float
      logoGroup.position.y = Math.sin(elapsed * 0.4) * 0.06;

      // Capture environment cubemap once (after first frame setup)
      if (!envCaptured && logoGroup.children.length > 0) {
        logoGroup.visible = false;
        cubeCamera.position.copy(logoGroup.position);
        cubeCamera.update(renderer, scene);
        logoGroup.visible = true;
        envCaptured = true;
      }

      // Two-pass rendering: background RT (for glass refraction) then scene RT
      logoGroup.visible = false;
      renderer.setRenderTarget(backgroundRT);
      renderer.render(scene, camera);
      logoGroup.visible = true;

      // Render full scene to sceneRT (not screen)
      renderer.setRenderTarget(sceneRT);
      renderer.render(scene, camera);

      // Bloom: bright extraction
      bloomBrightMat.uniforms.uSceneTex.value = sceneRT.texture;
      runBloomPass(bloomBrightMat, bloomBrightRT);

      // Bloom: gaussian blur (2 levels on mobile, 3 on desktop)
      runBlurLevel(bloomBrightRT, bloom0H, bloom0V, bw1, bh1);
      runBlurLevel(bloom0V, bloom1H, bloom1V, bw2, bh2);
      if (!isMobile) runBlurLevel(bloom1V, bloom2H, bloom2V, bw3, bh3);

      // Composite: scene + bloom → screen
      bloomCompositeMat.uniforms.uSceneTex.value = sceneRT.texture;
      bloomCompositeMat.uniforms.uBloom0.value = bloom0V.texture;
      bloomCompositeMat.uniforms.uBloom1.value = bloom1V.texture;
      bloomCompositeMat.uniforms.uBloom2.value = isMobile ? bloom1V.texture : bloom2V.texture;
      runBloomPass(bloomCompositeMat, null);
    }

    requestAnimationFrame(animate);
    setTimeout(() => { if (window._dismissLoader) window._dismissLoader(); }, 5000);

    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.fov = camera.aspect < 0.8 ? 55 : 40;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);

      // Update render target sizes
      const newW = Math.floor(innerWidth * Math.min(devicePixelRatio, maxDPR));
      const newH = Math.floor(innerHeight * Math.min(devicePixelRatio, maxDPR));
      backgroundRT.setSize(newW, newH);
      sceneRT.setSize(newW, newH);
      glassMaterial.uniforms.uTrnsWinRes.value.set(newW, newH);

      // Bloom RT resize
      bw1 = Math.floor(newW / 4); bh1 = Math.floor(newH / 4);
      bw2 = Math.floor(newW / 8); bh2 = Math.floor(newH / 8);
      bw3 = Math.floor(newW / 16); bh3 = Math.floor(newH / 16);
      bloomBrightRT.setSize(bw1, bh1);
      bloom0H.setSize(bw1, bh1); bloom0V.setSize(bw1, bh1);
      bloom1H.setSize(bw2, bh2); bloom1V.setSize(bw2, bh2);
      bloom2H.setSize(bw3, bh3); bloom2V.setSize(bw3, bh3);

    });
  </script>
</body>
</html>
